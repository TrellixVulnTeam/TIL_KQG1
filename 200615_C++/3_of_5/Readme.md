# 상속 & 도약

> 객체지향 프로그램의 핵심요소

1. [클래스상속](#inheritance)
2. [상속과 다형성](#상속과 다형성)
3. 추상 클래스
4. 다중 상속

</br>

## inheritance

> 기존에 정의된 클래스 멤버(변수, 함수)를 상속받아 새로운 멤버를 추가할 수 있는 기능

- 효율적 **유지보수** 가능

- 구성

  - 기본클래스 (상속해주는)
  - 파생클래스 (상속받는)

- #### 파생 클래스 선언 형식

  ```c++
  class 파생클래스명 [접근변경자] 기본클래스명 {
    [추가할 멤버 선언;]
    // 1. 상속받는 멤버
    // 2. 재정의한 멤버함수
    // 3. 새로 추가한 멤버 
  }
  ```

- 파생클래스 선언 예

  <img src="Readme.assets/image-20200630170630659.png" alt="image-20200630170630659" width="60%" />

  </br>

- #### 상속에서의 생성자 및 소멸자 호출 순서

  1. 기본 클래스 생성자
     - 기본 클래스로부터 상속 받은 멤버의 초기화 
  2. 파생 클래스 생성자
     - 추가된 멤버변수 초기화
     - 파생클래스 객체 생성 및 소멸 시 기본 클래스 생성자 및 소멸자의 호출은 가능하지만 상속은 불가능
  3. 파생클래스 소멸자
  4. 기본클래스 소멸자

</br>

- #### 인자를 필요로 하는 기본 클래스의 생성자 호출

  - 파생 클래스 생성자의 인자 전달 방법

    ```c++
    파생클래스명::파생클래스명(매개변수 목록)
      : 기본 클래스명(인자)
      {
        ...
      }
    ```

  - 기본 클래스 생성자의 인자 전달 방법

    ```c++
    기본클래스명::기본클래스명(매개변수 목록)
      :멤버변수(매개변수), ...
      {
        ...
      }
    ```

    - *초기화 리스트로 하지 않을 경우* 기본 클래스의 **디폴트 생성자**가 호출된다.
    - 직접 기본 클래스의 생성자 호출은 **객체의 임시 생성**에 불과하다.

</br>

- #### **접근 변경자**를 통한 세가지 형식의 상속

  ```c++
  class 파생클래스명:[접근변경자] 기본클래스명{
    [추가할 멤버 선언;]
  };
  ```

  - 상속에서의 접근 변경자 

    - `private`, `protected, ` `public`

      

  

- #### 상속 조건

  - **Is-a 관계**

    > 클래스간 상속 관계 구성을 위해 파생 클래스로 생성한 객체가 기본 클래스의 한 종류인 관계

    - 파생 클래스로 생성된 객체는 기본 클래스에서 제공하는 모든 멤버들이 이용할 수 있기 때문. (**역은 성립하지 않음**)

  - **has-a관계**

    > 특정 클래스에서 다른 클래스의 멤버를 사용할 수 있는 관계

    - 상속 없이 클래스 안의 한 멤버로 **다른 클래스를 포함**시켜 이용

  </br>

  </br>

  

## 상속과 다형성

- **다형성**

  > 동일한 명령문을 수행했는데 그 반응이 다른것을 말한다.

  

  - 객체 지향 프로그램의 가장 큰 특징

  - *예*

    - 함수 오버라이드

      : 기본 클래스에 있는 멤버함수의 **동일한 이름의 함수를 파생 클래스에서 다시 정의한 것**.

      - **시그니처(함수명, 매개변수 개수, 자료형 등)가 동일**해야 함수 재정의 가능
        - 다르면 *함수 오버로딩* 발생

  </br>

- **객체와 포인터 관계**

  - `Shape* ptr = new Shaep;`

    - `ptr`

      1. Shape 객체를 가리키는 객체 포인터,

      2. *Shape를 상속받은* Rectangle 클래스 객체를 가리키는 포인터
         	=> Shape 클래스 멤버 모두 Rectangle 클래스에서도 **접근 가능**하기 때문
         		**`Shape *ptr = new Rectangle;` 로 표현 가능.**
         		 	*Circle, Triangle 클래스 객체도 가능( 상속받았다면 )*

      

