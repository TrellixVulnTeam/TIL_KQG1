# C++

## 객체지향 언어로서의 C++ 특징

- 객체 지향 프로그램에서 사용되는 용어
  - 클래스 : 객체를 정의하는 원형
  - 객체 : 클래스에 정의된 대로 만들어진 실체(인스턴스)
  - 인스턴스 : 프로그램에서 실제로 실행할 객체
  - 메소드 : 클래스에 정의된 연산(함수)
  - 메시지 : 객체를 통해 메서드를 호출하는 

1. ### 데이터 추상화

   >  실생활에서 다루는 방법과 유사하게 프로그램 처리 하기 위해 **특정 대상의 주요 특성만을 모델링** 하는 것.

</br>

2. ### 캡슐화

   > 객체 관련 데이터 및 함수들을 하나로 묶은 것

   - **정보의 은닉**

     : 객체간 역할 구분 -> 쉬운 프로그램 모듈화 구현 지원


</br>

3. ### 상속

> 기정의된 클래스에 데이터나 함수를 추가하거나 수정해 재정의하는 기능

- 기존 클래스와 파생 클래스 간 **계층구조** 구성 -> 쉬운 클래스 라이브러리 구축

</br>

4. ### 다형성

> 동일한 이름의 함수가 상황에 따라 다르게 동작하느 것

- 중복정의 (오버로딩) & 재정의 (오버라이딩)

</br>

</br>

## 일반화 프로그래밍 언어로서의 C++ 특징

- ### 일반화 프로그래밍 ? 

  : 함수 및 클래스 정의시 범용형 (Generic Type) 사용

    C++에서는 템플릿을 이용하여 기능 지원

  - #### 함수 템플릿

    : 함수 정의 대신 **함수를 만들어내는 방법 정의**

     주로 처리하는 방법은 동일하나 대상이 되는 **데이터의 자료형이 다양한 경우** 사용

  - #### 클래스 템플릿

    : 클래스 정의 대신 **클래스를 생성하는 방법 정의** 

</br>

## Main 함수

> 프로그램이 실행될 때 운영체제에 의해 호출되는 함수 : **진입(Entry Point함수**

리턴 자료형

프로그램 종료 시 운영체제에 반환되는 값

실행 형태

프로그램 실행 불가 시 : 1 반환

정상 종료 시 : 0 반환

</br>

## cout객체 

> 터미널(표준 출력 장치)로 출력될때 사용되는 객체
>
> `<<` 연산자

`count<<"안녕하세요";` ---> 안녕하세요

### 줄바꿈 연산자 `endl`

- 줄바꿈
- **출력 버퍼를 비움**

`count<<"안녕하세요,"<<"만나서 반갑습니다." <<endl;`



`#include <iostream>` 선언 필요

표준 라이브러리 클래스, 함수, 변수 등 사용시 std네임스페이스 지정해야 함.

`std::cout`
`std::endl` 

번거로우면 `using namespace std;`  사용

</br>

## 자료형

>  변수나 객체의 형식 또는 그 크기를 구분하는 용도로 사용

### C++ 제공 자료형

- 기본 자료형

  - 논리, 문자, 정수, 실수
  - C++에서 추가된 자료형
    - 논리형 (bool)
    - 문자형 (wchar_t : 2 or 4 byte (플랫폼에 따라 크기가 다름))
  - 플랫폼에 따라 크기가 다른 자료형
    - 정수형( long, unsigned long  4(32bit) or 8 byte((64bit)))
    - 실수형 ( long double 8 or 10 or 16 byte )
    
      </br>

- 자료형의 크기 확인 방법

  - `sizeof()`

  </br>

- 정수형 기본 자료형의 크기

  - signed
    
    - **부호비트** 추가, 표현범위 : **-32768 ~ 32767** (short 형)
    
    </br>
  - unsigned
    - 음수의 데이터가 없는 경우
    - 표현범위 : **0 ~ 65535** (short 형)

  </br>

  - **데이터 오버 플로우**가 일어날 수 있기 때문에 자료형의 크기 선택을 고려해야한다.

  </br>

- 사용자 정의 자료형

  - 열거형 (enum)
  - 문자열
  - 포인터
  - 배열
  - 구조체 (struct)
  - 공용체 (union)
  - 클래스 (class)
  - typedef




</br>

- ### Typedef

  > 사용자가 이름을 부여함.

  왜 ?

  1. 가독성

  2. 다양한 플랫폼에 포팅이 가능한 프로그램 작성 가능

     Ex) 

     ```c
     
     unsigned int num1, num2;
     unsigned int get_addr(char* add);
     char* put_addr(unsigned int addr);
     
     // --> 모든 줄의 int형을 long형으로 바꾸어야해서 번거롭다
     
     
     typedef unsigned int unit32;
     unit32 num1, num2;
     unit32 get_addr(char* add);
     char* put_addr(unit32 addr);
     
     // --> 맨위에 형변환만 해주면 된다.
       
     전제조건
     : 32비트 정수? int형 크기 4바이트(32bit) 플랫폼 : int형 사용
        				   int형 크기 2바이트(16bit) 플랫폼 : 4바이트 자료형은 long형
     ```


</br>

- ### Enum

  > 하나 이상의 정수형 상수를 원소로 갖는 열거형의 enum

   `enum colors {red, blue, yellow, green, white, black} mycolor;`

  `mycolor = red ` : mycolor 변수에 **0대입**

  `mycolor == blue` : mycolor변수의 값이 blue, **1인지 비교**

  </br>

  왜 ?

  - 가독성
  - 수가 상징하는 의미를 문자로 작성하면 분석이 용이하다.

  ```c
  enum color {red=10, blue=20, yellow, green, white, black} mycolor;
  
  /* yellow는 30이 아니다
    값이 부여된 blue부터 순차적으로 증가함
    yellow 는 21, green은 22
    
   */
  ```

  </br>

## 변수

1. ### 변수 선언

`int num1 = 0, num2(-1);`

**C++에서는 변수도 객체의 한 종류로로 생각한다.**

</br>

2. ### 지역변수, 전역변수

   1. 함수 내 선언 : 지역변수 
   2. 함수 외부 선언 : 전역변수
   3. <img src="Readme.assets/image-20200616163354838.png" alt="image-20200616163354838" width="70%" />

   </br>

   

3. ### 정적변수 

   > 함수 내에서만 사용하는 변수 (static)

   - 함수가 종료되어도 그 값을 유지하고 싶을때 사용한다.
   - **데이터 세그먼트**에 할당된다
   - `static int total = 0;`



</br>

### 상수

#### 리터럴 상수

- 논리상수
- 정수형 상수
- 실수형 상수 
- 문자 및 문자열 상수
- **"" 와 ''는 다르다**
  - 'A' : A문자를 의미
  - "A" : **A문자와 문자열 끝을 알리는 '\0' 문자를 결합**한 **2바이트**의 메모리에 표현, `A+\0`문자열의 **시작주소**를 의미

#### 심볼릭 상수 (`const`)

> 상수를 기호화해서 사용하는 심볼릭 상수

- 상수화된 변수는 **선언 시 반드시 초기화**되어야 한다.
- `const 자료형 변수명 = 초기값;`
- 초기화 값은 **중간에 변경 불가**
- 상수처럼 사용됨

</br>

## 표준 입출력

> iostream 라이브러리에서 제공

- 출력 : `cout`
- 입력 : `cin`
- `cin >> 변수;`
  - **공백, Tab, Enter**를 만나기 전까지의 변수의 자료형에 맞는 데이터를 입력받는다

</br>

## 연산자

- 범위지정 연산자 (`::`)
  - 함수내에 선언된 지역변수와 전역변수 **이름이 동일**할 때, 전역변수를 지정할 때 사용한다.
  - 예 ) `::count`

</br>

## Namespace

- 내가 지정한 네임스페이스 공간 //  구분  // 관련없는 공간

- ```c++
  namespace [네임스페이스 이름]{
  변수 선언;
  함수선언;
  }
  ```

- **생략**하면 **같은 파일 안에서만** 접근 가능

- **함수 외부**에서 정의해야 한다.

- **사용하려는 함수 앞**에 정의해야 한다.

  

### 네임스페이스로 정의된 공간의 변수, 함수로 접근하려면?

- `네임스페이스 이름 :: 함수명 또는 변수명`
- 중첨되어 있을땐 ? **순서대로 (바깥 --> 안쪽)** 연산자 사용!
- 일일이 선언하지 않고 싶을 땐? `using`



</br>

## 선택문 & 반복문 & 제어문



1. ### 선택구조

   참, 거짓 기준은 **0** : <u>**0이 아닌경우가 참**</u>

   1. #### If

   2. #### switch

      : 조건식은 **정수형상수**이거나 **문자형 상수**여야한다.

      default는 생략가능	

   3. #### if VS switch ?

      : 최적화하는 방법은 **switch**가 더 나음

      ​	다중if는 조건식을 처음부터 일일이 비교,
      ​	switch는 case중 하나만 선택되어 실행

</br>

2. ### 반복구조

   1. #### for

   2. #### while

   3. #### do-while

</br>

3. ### 기타구조

   > 프로그램의 흐름을 지정한 위치로 이동하고 싶을  사용

   1. #### goto문

      - 실행되는 도중 특정 위치로 이동해야 하는 경우 사용, goto문의 대상이 되는 위치에는 **레이블**을 붙인다.

      - ```c++
        label 명 :
        			~
                goto label명;
        ```

   2. #### break문

      - <u>if함수에서 사용 불가</u>

   3. #### continue문

      - 다음 주기로 넘어감
      - <u>switch문에서는 사용 불가</u>



</br>

## 배열과 포인터

> 수많은 데이터를 보관하는데에 변수로는 부족하다
>
> 이를 위해, 변수 이외에 데잍를 처리하는 방법을 활용한다.

### 방법

- #### 배열

  > 동일한 데이터들이 메모리에 연속적으로 모여있는 것.

  - 크기가 정해져있다.

  </br>

- #### 포인터

  >  메모리를 제어할 수 있는 기능

  - 프로그램이 실행되는 공간인 메모리를 가리킴

  - 메모리의 주소 : 포인터

</br>

- #### 레퍼런스

  > 별도의 메모리를 **할당하지 않음.**	
  >
  > 기존에 존재하는 변수의 메모리를 함께 공유
  >
  > 어떤 변수의 **'별명'**

  - `&` 지정자 사용
  - 선언과 동시에 어떤 변수와 초기화 할 것인지를 명시해야함.
    - *변수 선언 : 메모리 할당*
  - 나중에 다른변수를 참조하도록 **변경 불가.**

</br>

- #### 레퍼런스와 포인터의 차이

  - 포인터
    - 가리키는 대상이 없을수도 있고, 달라질 수도 있다.
    - 함수간의 인자 전달 시 **주소 전달**로 다른 함수의 변수를 이용
  - 레퍼런스 변수
    - 반드시 **가리키는 대상이 존재**해야하고 **달라질 수 없다.**
    - 함수간의 인자 전달 시 다른 함수의 변수에 **별명을 붙여** 바로 사용 
      - (포인터보다 사용이 쉬워 주로 함수의 **인자 전달방법**으로 사용된다.)

</br>