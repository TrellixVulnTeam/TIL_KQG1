# C++

## 객체지향 언어로서의 C++ 특징

- 객체 지향 프로그램에서 사용되는 용어
  - 클래스 : 객체를 정의하는 원형
  - 객체 : 클래스에 정의된 대로 만들어진 실체(인스턴스)
  - 인스턴스 : 프로그램에서 실제로 실행할 객체
  - 메소드 : 클래스에 정의된 연산(함수)
  - 메시지 : 객체를 통해 메서드를 호출하는 

2. ### 데이터 추상화

> 실생활에서 다루는 방법과 유사하게 프로그램 처리 하기 위해 **특정 대상의 주요 특성만을 모델링** 하는 것.



2. ### 캡슐화

   > 객체 관련 데이터 및 함수들을 하나로 묶은 것

   </br>

   - **정보의 은닉**

     : 객체간 역할 구분 -> 쉬운 프로그램 모듈화 구현 지원

3. ### 상속

   > 기정의된 클래스에 데이터나 함수를 추가하거나 수정해 재정의하는 기능

   </br>

   - 기존 클래스와 파생 클래스 간 **계층구조** 구성 -> 쉬운 클래스 라이브러리 구축
   - 

4. ### 다형성

   > 동일한 이름의 함수가 상황에 따라 다르게 동작하느 것

   </br>

   - 중복정의 (오버로딩) & 재정의 (오버라이딩)



## 일반화 프로그래밍 언어로서의 C++ 특징

- ### 일반화 프로그래밍 ? 

  : 함수 및 클래스 정의시 범용형 (Generic Type) 사용

    C++에서는 템플릿을 이용하여 기능 지원

  - #### 함수 템플릿

    : 함수 정의 대신 **함수를 만들어내는 방법 정의**

     주로 처리하는 방법은 동일하나 대상이 되는 **데이터의 자료형이 다양한 경우** 사용

    </br>

  - #### 클래스 템플릿

    : 클래스 정의 대신 **클래스를 생성하는 방법 정의** 



## Main 함수

> 프로그램이 실행될 때 운영체제에 의해 호출되는 함수 : **진입(Entry Point함수**

리턴 자료형

프로그램 종료 시 운영체제에 반환되는 값

실행 형태

프로그램 실행 불가 시 : 1 반환

정상 종료 시 : 0 반환



## cout객체 

> 터미널(표준 출력 장치)로 출력될때 사용되는 객체
>
> `<<` 연산자

`count<<"안녕하세요";` ---> 안녕하세요

### 줄바꿈 연산자 `endl`

- 줄바꿈
- **출력 버퍼를 비움**

`count<<"안녕하세요,"<<"만나서 반갑습니다." <<endl;`



`#include <iostream>` 선언 필요

표준 라이브러리 클래스, 함수, 변수 등 사용시 std네임스페이스 지정해야 함.

`std::cout`
`std::endl` 

번거로우면 `using namespace std;`  사용



## 자료형

>  변수나 객체의 형식 또는 그 크기를 구분하는 용도로 사용

### C++ 제공 자료형

- 기본 자료형

  - 논리, 문자, 정수, 실수
  - C++에서 추가된 자료형
    - 논리형 (bool)
    - 문자형 (wchar_t : 2 or 4 byte (플랫폼에 따라 크기가 다름))
  - 플랫폼에 따라 크기가 다른 자료형
    - 정수형( long, unsigned long  4(32bit) or 8 byte((64bit)))
    - 실수형 ( long double 8 or 10 or 16 byte )
    - </br>

- 자료형의 크기 확인 방법

  - `sizeof()`

  </br>

- 정수형 기본 자료형의 크기

  - signed
    - **부호비트** 추가, 표현범위 : **-32768 ~ 32767** (short 형)
  - unsigned
    - 음수의 데이터가 없는 경우
    - 표현범위 : **0 ~ 65535** (short 형)
  - **데이터 오버 플로우**가 일어날 수 있기 때문에 자료형의 크기 선택을 고려해야한다.

  </br>

- 사용자 정의 자료형

  - 열거형 (enum)
  - 문자열
  - 포인터
  - 배열
  - 구조체 (struct)
  - 공용체 (union)
  - 클래스 (class)
  - typedef

  

- ### Typedef

  > 사용자가 이름을 부여함.

  왜 ?

  1. 가독성

  2. 다양한 플랫폼에 포팅이 가능한 프로그램 작성 가능

     Ex) 

     ```c
     
     unsigned int num1, num2;
     unsigned int get_addr(char* add);
     char* put_addr(unsigned int addr);
     
     // --> 모든 줄의 int형을 long형으로 바꾸어야해서 번거롭다
     
     
     typedef unsigned int unit32;
     unit32 num1, num2;
     unit32 get_addr(char* add);
     char* put_addr(unit32 addr);
     
     // --> 맨위에 형변환만 해주면 된다.
       
     전제조건
     : 32비트 정수? int형 크기 4바이트(32bit) 플랫폼 : int형 사용
        				   int형 크기 2바이트(16bit) 플랫폼 : 4바이트 자료형은 long형
     ```

     

- ### Enum

  > 하나 이상의 정수형 상수를 원소로 갖는 열거형의 enum

   `enum colors {red, blue, yellow, green, white, black} mycolor;`

  `mycolor = red ` : mycolor 변수에 **0대입**

  `mycolor == blue` : mycolor변수의 값이 blue, **1인지 비교**

  </br>

  왜 ?

  - 가독성
  - 수가 상징하는 의미를 문자로 작성하면 분석이 용이하다.

  ```c
  enum color {red=10, blue=20, yellow, green, white, black} mycolor;
  
  /* yellow는 30이 아니다
    값이 부여된 blue부터 순차적으로 증가함
    yellow 는 21, green은 22
    
   */
  ```

  </br>

## 변수

1. ### 변수 선언

`int num1 = 0, num2(-1);`

**C++에서는 변수도 객체의 한 종류로로 생각한다.**

2. 지역변수, 전역변수
   1. 함수 내 선언 : 지역변수 
   2. 함수 외부 선언 : 전역변수
   3. <img src="Readme.assets/image-20200616163354838.png" alt="image-20200616163354838" width="70%" />
3. 

