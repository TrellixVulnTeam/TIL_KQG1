### 스칼라

- 코드의 직관성과 신축성
- 풍부한 표현식과 연산자
  - first-class fucntion
  - closure
- 간결함
  - 타입추론
  - 함수 리터럴(Literal)
- 자바와의 혼용 가능 객체지향 + 함수형 언어
  - 자바 라이브러리 재사용 가능
  - 자바 도구를 재사용 가능
  - 성능 손실 없이 사용 가능
  - 스칼라에서는 모든 것이 객체

- 동시성에 강한 언어

  - 스칼라에서는 많은 부분이 변경불가능 속성을 가지게끔 되어있다.
  - 아카(Akka)라이브러리  - 동시성 프로그래밍에서 뛰어난 액터 모델을 이용
  - 액터 모델은 가각의 액터가 서로간의 메세지를 통해서만 의사소통을하고 , 액터를 이루는 각종 변수나 속성은 서로 공유하지 않는다. (액터를 함수로 보는데, 함수끼리 공유하지 않는다)

- expression표현 (결과를 반환하는 문장) 중심 언어

- 필요할 때 implicit 예약어를 사용하면 명시적인 표현을 감춰버릴 수 있다.

- 함수형 프로그래밍

  - 프로그래밍 패러다임의 하나로 자료처리를 수학적 함수의 계산으로취급하고 상태변화와 가변 데이터를 피하는 것.

- 익명함수

  - 선언부가 없어 코드 길이를 줄이고, 로직에 집중할 수 있다.

    reduce(a,b)->a-b)get();

- 고차함수

  - 함수를 인수로 취급하는 함수. 

    `Collections sort(new ArrayList<Integer>(),(x,y)->x >= y ?-1:1);`

---

### Scala 설치

![scalar install](https://user-images.githubusercontent.com/50945713/63658173-90a8dc80-c7e3-11e9-8cbf-4f6d804a1327.png)



`Object Ex1{
def main(args : Array(String(): Unit ={
println("Hello Scala !")}
)
}`

- 함수는 def로 정의

  - 접근 제한자 없음

  - Unit은 자바의 void와 동일

- 문장 끝에 세미콜론 없음

  - 메서드에 매개변수를 넣어줄 때도 여러줄이면 method()형태가 아닌 method{} 사용

- JVM기반 함수형 언어
- scala bin 디렉토리 아래 실행파일이 있다.
- 변수 선언 var, val(불변 변수 선언), 변수 타입 생략 가능
- Range타입 - 1to 10, 1 to 10 by 2, 리스트나 배열 타입으로는 <u>형변환</u>을 해야함



### Hello Scala 출력

메모장 컴파일 test폴더 ex1.scala

`object Ex1 {
def main(args: Array[String]):Unit ={
println("Hello Scala!")
}
}`

scalac ex1.scala

![scalacompile](https://user-images.githubusercontent.com/50945713/63658991-bcc75c00-c7e9-11e9-9c2e-9fc6a63c8a22.png)

### 변수와 타입

- var : 언제든 변경 가능한 일반적인 변수
- val : final변수
- 변수의 값으로 null이나 None으로 초기화 할수 있음 (None 권장)



- 참조 자료형

  - String
  - Unit
  - Null
  - Nothing
  - Any
  - AnyVal
    : 기본값 타입의 부모 타입
  - AnyRef 
    :참조 타입의 부모 타입

- 문자열

  - 스칼라에서 문자열의 표현은 ""를 이용
  - 멀티라인 문자열은 """ 이용

- 접두어를 이용한 문자열 처리

  - 접두어 (id) 를 붙여 컴파일 시점에 문자열 변환 처리
  - s, f, raw,  사용자 정의

- 문자열 처리 - 접두어 s
  : 문자열안의 변수를 값으로 치환 계산식, 함수도 사용 가능

- 접두어 f
  : 문자열 포맷팅 처리, 자바의 printf()와 같은 방식
  ![f](https://user-images.githubusercontent.com/50945713/63659303-ac17e580-c7eb-11e9-885f-e787bb8b8a52.png)

  

- 접두어 raw
  : 특수문자 처리 않고 원본 문자로 인식
  ![raw](https://user-images.githubusercontent.com/50945713/63659370-04e77e00-c7ec-11e9-91e7-c83b7562e305.png)



- 정리
  ![type](https://user-images.githubusercontent.com/50945713/63659530-d9b15e80-c7ec-11e9-90a4-8d042d80377b.png)



- Range 타입 
  type 예약어는 자료형이 복잡한 경우 별칭을 주어 쉽게 쓸수 있게 한다.

  ```scala
  scala> type Name=String
  defined type alias Name
  
  scala> type Person=(String,int)
                             ^
         error: not found: type int
  
  scala> type Person=(String,Int)
  defined type alias Person
  
  scala> type Ftype=String=>Int
  defined type alias Ftype
  
  scala> val name:Name="홍길동"
  name: Name = 홍길동
  
  scala> println(Name)
                 ^
         error: not found: value Name
  
  scala> println(name)
  홍길동
  
  scala> val person:Person =("korea",24)
  person: Person = (korea,24)
  
  scala> val f:Ftype=text=>text:toInt
                                ^
         error: not found: type toInt
  
  scala> val f:Ftype=text=>text.toInt
  f: Ftype = $$Lambda$880/1350490636@5b218570
  ```

  

- 조건문 : if/else

- 반복문 : for, while,do while

  ```scala
  scala> for (x <- 1 to 10){}
  
  scala> for (x <- 1 until 10){println(x)}
  1
  2
  3
  4
  5
  6
  7
  8
  9
  
  scala> for( i <- 10) if(i%2==0){println(i)}
                   ^
         error: value foreach is not a member of Int
  
  
  scala> for( i <- 10) if (i%2==0){
       | println(i)}
                   ^
         error: value foreach is not a member of Int
  
  scala> for( i <- 1 to 10) if (i%2==0){
       | println(i)}
  2
  4
  6
  8
  10
  
  scala> for((num,index)<-lst.zipWithIndex){
       | println(s"$index : $num")
       | }
  0 : 10
  1 : 20
  2 : 30
  3 : 40
  4 : 50
  5 : 60
  6 : 70
  7 : 80
  8 : 90
  9 : 100
  
  scala> for(x <- 1 until 5 ; y <- 1 until 5){
       | print(x + " * " + y + " = " + x*y + "|")
       | }
         print(x + " * " + y + " = " + x*y + "|")
                 ^
  On line 2: warning: method + in class Int is deprecated (since 2.13.0): Adding a
   number and a String is deprecated. Use the string interpolation `s"$num$str"`
  1 * 1 = 1|1 * 2 = 2|1 * 3 = 3|1 * 4 = 4|2 * 1 = 2|2 * 2 = 4|2 * 3 = 6|2 * 4 = 8|
  3 * 1 = 3|3 * 2 = 6|3 * 3 = 9|3 * 4 = 12|4 * 1 = 4|4 * 2 = 8|4 * 3 = 12|4 * 4 =
  16|
  ```

- 함수

  - 변수와 마찬가지로 ; 을 이용해 반환  자료형을 정의하며 반환 자료형이 함수의 자료형을 결정

  - 반환값이 있을때에도 반환자료형 생량 가능

  - <u>명시적으로 return을 사용하는 경우 함수 선언하는 곳에도 반환 자료형을 명시해야함</u>

  - 반환 자료형을 명시한 경우 다른 자료형을 반환하려고 하면 에러 발생

    `def 함수명({매개변수}): {반환자료형 }={
    //구현할 로직
    }`

  ```scala
  scala> def name () = {
       | val a =10
       | a
       | }
  name: ()Int
  
  scala> def name (): Int ={
       | val a =10
       | return a
       | }
  name: ()Int
  
  scala> name()
  res35: Int = 10
  
  scala> def name3 () ={
       | val a =10
       | return a
       | }
         return a
         ^
  On line 3: error: method name3 has return statement; needs result type
  ```

  

  - 함수 인자의 타입을 명시해야함
  - 인자가 없는 함수의 경우 호출시 괄호 생략 가능
  - 이름없는 함수 만들 수 있다
  - 익명함수를 다른 함수나 식에 넘기거나 val에 저장 가능
  - 함수가 여러 식으로 이루어진 경우 {}를 이용해 이를 위한 공간을 만들 수 있다.

  ```scala
  scala> def addOne(m:Int):Int =m +1
  addOne: (m: Int)Int
  
  scala> val three =addOne(2)
  three: Int = 3
  
  scala> def three() =1+2
  three: ()Int
  
  scala> three()
  res36: Int = 3
  
  scala> three
  res37: Int = 3
  
  //익명함수
  scala> (x:Int) => x+1
  res38: Int => Int = $$Lambda$1094/1484672206@27cae2dc
  
  scala> val addOne=(x:Int) =>x +1
  addOne: Int => Int = $$Lambda$1095/238567998@497d99f8
  
  scala> addOne(1)
  res40: Int = 2
  
  
  scala> def tiemsTwo(i:Int):Int ={
       | println("hello world")
       | i*2
       | }
  tiemsTwo: (i: Int)Int
  
  scala> {i:Int=>
       | println("hello world")
       | i*2
       | }
  res42: Int => Int = $$Lambda$1096/1933565076@5a1da8f3
  ```

- 인자의 일부만 사용해 호출하기 (부분 적용,  Partial application)

  - 함수 호출시 밑줄(_) 을 사용해 일부만 적용할 수 있다. 그렇게 해서 새로운 함수를 얻는다 . 문맥에 따라 의미가 다름
  - 보통 이름없는 마법의 문자로 생각 
    '(_ + 2 )' 이라는 문맥에서 밑줄은 이름없는 매개변수
  - 인자 중 원하는 어떤 것이든 부분 적용이 가능함. 꼭 맨 마지막 위치가 아니더라도 아무곳에서 밑줄을 넣을 수 있다.

  ```scala
  scala> def adder(m:Int,n:Int) =m+n
  adder: (m: Int, n: Int)Int
  
  scala> val add2=adder(2,_:Int)
  add2: Int => Int = $$Lambda$1097/1437925850@35b6edce
  
  scala> add2(3)
  res43: Int = 5
  ```

- 커리 함수(Curried Function)

  - 함수의 인자중 일부를 적용하고 나머지는 나중에 적용하게 남겨두는 경우

  ```scala
  scala> def main(args:Array[String]):Unit={
       | val thisYear=2019
       | val fixedValueFunction = go(thisYear,
       | fixedValueFunction("test1")
       | fixedValueFunction("test2")
       | fixedValueFunction("test3")
       | }
  main: (args: Array[String])Unit
  
  scala> def go(thisYear:Int, string:String)={
       | println(string + ":" + thisYear)}
  go: (thisYear: Int, string: String)Unit
  
  ```

- => 를 이용한 함수 표현식

  - 스칼라 컴파일러는 => 표현식을 보면 실제로는 function 객체로 선언함
  - 스칼라는 매개변수가 하나면 Function1, 두개면 Fucntion2, ,,,, 22개까지 Function을 상속하는 트레이트를 제공함

- 변수에 함수 넣기
  - 명시적으로 함수가 기대되지 않는 곳에서 = 연산자 이용해 대입한 경우 에러 발생
  - 객체화 되어 있지 않은 함수를 바로 val에 대입하면 에러 발생

