

## Array

### Array순회

- N x M 행렬의 원소를 빠짐없이 조사하는 방법

  1. 행 우선 선회

     - 행을 우선으로 Array의 원소를 조사하는 방법

       가로로 쭈우우우우욱

  2. 열 우선 선회

     - 열을 우선으로 Array의 원소를 조사하는 방법

       세로로 쭈우우우우욱

  3. 지그재그 순회

     - 첫행은 우측, 다음행은 좌측으 조사

     - ```c
       int i; // 행으 좌표
       int j; // 열의 좌표
       
       for i from 0 to n-1
         for j from - to m-1
           Array[i][j+(m-1-2*j) *(i %2)];
       
       ```

### 델타를 이용한 2차 Array탐색

- 2차 Array의 한 좌표에서 네 방향의 인접 Array 요소를 탐색할  때 사용하는 방법

- **델타값** ; 한 좦에서  네 방향의 자표와 x, y의 차이를 저장한 Array

- 델타값을 이용해 특정 원소의 상하좌우에 위치한 원소에 접근

- ```c
  dx[] <- {0,0,-1,1};
  dy[] <- {-1,1,0,0};
  
  for x,y from 0. to n-1
    for i from.0 to 3{
      testX <- x + dx[mode];
      testY <- y + dy[mode];
      test(ary[testX][testY]);
    }
  ```



### 전치 행렬

- 행과 열의 값이 반대인 행렬

- ```c
  int arr[3][3];
  int i;
  int j;
  
  for i from 0 to 2
    for j from 0 to 2
      if(i<j)
        swap(arr[i][j], arr[j][i]);
  ```

- 모든 좌표에 대해 행과 열의 값을 바꾸면 원래상태로 돌아온다.!





## 부분집합

### 부분집합의 합 문제

> 집합 안의 원소를 모두 더한 값이 0 이 되는 경우가 있는지 조사하는 문제

- 모든 부분집합을 생성한 후 , 각 부분집합의 합을 계산
  - 주어진 **부분집합을 생성하는 방법** 생각하는게 우선
- ㄴ

## DP (동적계획법) Dynamic Programming

​    \- 그리디 알고리즘 설계기법과 같이 최적화 문제를 해결하는 알고리즘 설계 기법

​    \- 입력크기가 작은 부분들을 모두 해결하고 그 해들을 이용해 보다 큰 크기의 문제들을 해결하는 방법



1) 문제를 부분문제로 분할

2) 가장 작은 부분 문제부터 해를 구함

3) 그 결과를 테이블에 저장 후 테이블에 저장된 부분 문제의 해를 이용해 상위문제를 해결한다.



구현방식

1. recursive방식

​    \- 내부에 시스템 호출 Stack을 사용하는 overhead가 발생할 수 있다.

2. 반복문 iterative방식

​    \- 재귀보다 성능면에서 보다 효율적



### Memoization

메모리에 넣기

\- 이전 계산 값을 메모리에 저장해 매번 다시 계산하지 않도록해 실행속도를 빠르게 하는 기술

\- DP(동적계혹)의 핵심이 되는 기술





## DFS (깊이우선탐색)

\- 비선형적 구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다.

\- 깊이우선탐색(DFS)

\- 너비우선탐색(BFS)



한 방향으로 갈 수 있는 경로가 있는곳까지 깊이 탐색

다시 되돌아오기 위해 Stack을 사용했다.