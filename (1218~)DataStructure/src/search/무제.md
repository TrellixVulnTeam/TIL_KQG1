## 복잡도

> 알고리즘의 성능을 평가하는 기준



### 시간복잡도

> 실행에 필요한 시간을 평가한 것

### 공간복잡도

> 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것



### 선형 검색의 시간 복잡도

```java
static int seqSearch(int[] a, int n, int key){
int i = 0 ;      // -----1
while( i < n){  //-----2
	if(a[i]=key)   //-----3
	return i;}  //------4
i++;}
return -1;// ---------6
}
```

한번만 실행하는 경우 복잡도는 : **O(1**) (1번)

메서드에서 값을 반환하는 경우도 한번만 실행하기 때문에 **O(1)** (4,6번)

2번,3번의 평균 실행횟수는 n/2

n에 비례하는 횟수만큼 실행하는 경우의 복잡도 : **O(n)**



### Big O 표기법의 종류

- O(1) : 상수 (Constant)

  - 입력되는 데이터에 상관없이 일정한 실행 시간
  - 오직 한단계만 거친다. 

- O(logN) : Logarithmic

  - 데이터 양이 많아지면 시간이 조금씩 늘어난다

  - 시간에 비례하여, 탐색 가능한 데이터양이 2의 n승이 된다.

    문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.

  - 만약 입력 자료의 수에 따라 실행 시간이 이 log N 의 관계를 만족한다면 N이 증가함에 따라 실행시간이 조금씩 늘어난다. 이 유형은 주로 커다란 문제를 일정한 크기를 갖는 작은 문제로 쪼갤때 나타나는 유형이다.

  - Binary Search

- O(N) Linear

  - 데이터양에 따라 시간이 정비례한다.
  - linear search, for 문을 통한 탐색을 생각하면 되겠다.

- O(N log N) log linear

  - 데이터양이 N배 많이 진다면, 실행 시간은 N배 보다 조금더 많아 진다. (정비례 하지 않는다.)
  - 이 유형은 커다란 문제를 독립적인 작은 문제로 쪼개어 각각에 대해 독립적으로 해결하고,나중에 다시 그것들을 하나로 모으는 경우에 나타난다. N이 두배로 늘어나면 실행 시간은 2배보다 약간 더 많이 늘어난다.
  - 퀵소트, 머지소트

- O(N^2) Quadratic

  - 데이터양에 따라 걸리는 시간은 제곱에 비례한다. (효율이 좋지 않음, 사용하면 안된다)
  - 이 유형은 이중루프내에서 입력 자료를 처리 하는 경우에 나타난다. N값이 큰값이 되면 실행 시간은 감당하지 못할 정도로 커지게 된다.
  - 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱
  - 2중 for 문을 사용하는 버블소트, 삽입정렬(insertion sort)